---
name: parallel-subagents
description: 子代理并行策略 - 任务拆分、并行处理、Token优化、模型分级
---

# 子代理并行策略 (Parallel Subagents)

> 大任务拆分为多个子任务并行处理，提升效率，降低Token消耗
> 适用场景：复杂任务、多步骤工作、需要查资料+执行+总结的场景

---

## 核心原则

### 1. 任务拆分策略

**什么任务适合并行？**
- ✅ 多维度研究（查资料+分析+总结）
- ✅ 代码开发（设计+编码+测试+文档）
- ✅ 内容创作（调研+撰写+编辑+排版）
- ✅ 数据分析（清洗+分析+可视化+报告）

**什么任务不适合并行？**
- ❌ 强依赖顺序（必须A完成后才能B）
- ❌ 需要实时反馈调整（创意迭代类）
- ❌ 简单任务（拆分开销>收益）

---

## 典型分工模式

### 模式1：研究型任务
```
主代理：定义研究问题
├── 子代理A（资料搜集）：搜索相关文献/资料
├── 子代理B（数据分析）：整理和分析数据
└── 子代理C（总结提炼）：综合结论和建议

并行执行 → 主代理整合结果
```

### 模式2：代码开发
```
主代理：定义需求和架构
├── 子代理A（架构设计）：设计系统结构
├── 子代理B（核心实现）：编写主要代码
└── 子代理C（测试文档）：编写测试和文档

并行执行 → 主代理代码审查和集成
```

### 模式3：内容创作
```
主代理：确定主题和风格
├── 子代理A（素材搜集）：收集案例和数据
├── 子代理B（内容撰写）：撰写主体内容
└── 子代理C（润色优化）：语言优化和格式调整

并行执行 → 主代理最终审核
```

---

## 模型选择策略

### 模型分级使用

| 任务类型 | 推荐模型 | 理由 |
|---------|---------|------|
| **资料搜集** | kimi-k2.5 / gemma-2-9b | 快速、便宜、足够准确 |
| **代码实现** | kimi-k2.5 / deepseek-coder | 代码能力强 |
| **分析总结** | kimi-k2.5 / claude-sonnet | 推理能力强 |
| **关键决策** | kimi-k2.5 / claude-opus | 高精度、复杂推理 |

### Token成本控制

**并行优势：**
```
单代理模式：
- 1个长会话 = 100K tokens

并行模式：
- 子代理A = 20K tokens
- 子代理B = 25K tokens  
- 子代理C = 20K tokens
- 主代理整合 = 15K tokens
- 总计 = 80K tokens（节省20%）
```

**关键技巧：**
- 子代理只返回**摘要/结果**，不返回完整思考过程
- 主代理只接收**结构化输出**，减少上下文膨胀
- 复杂子任务再细分为孙代理（递归拆分）

---

## OpenClaw实施方法

### 1. 启动多个子代理

```javascript
// 同时启动3个子代理
const tasks = [
  {
    agentId: "main",
    task: "研究任务A：搜集关于XXX的资料",
    model: "moonshot/kimi-k2.5",
    timeoutSeconds: 180
  },
  {
    agentId: "main", 
    task: "研究任务B：分析YYY数据",
    model: "moonshot/kimi-k2.5",
    timeoutSeconds: 180
  },
  {
    agentId: "main",
    task: "研究任务C：总结ZZZ要点",
    model: "moonshot/kimi-k2.5",
    timeoutSeconds: 180
  }
];

// 并行执行
const results = await Promise.all(
  tasks.map(t => sessions_spawn(t))
);
```

### 2. 子代理配置（Minimal模式）

```json
{
  "sessionTarget": "isolated",
  "model": "moonshot/kimi-k2.5",
  "promptMode": "minimal",
  "timeoutSeconds": 180
}
```

**Minimal模式优势：**
- 减少系统提示词（~节省30% tokens）
- 不加载心跳、记忆等模块
- 专注单一任务

### 3. 结果汇总策略

```
子代理A返回：
{
  "task": "资料搜集",
  "status": "完成",
  "key_findings": ["要点1", "要点2", "要点3"],
  "sources": ["链接1", "链接2"],
  "confidence": "高"
}

子代理B返回：
{
  "task": "数据分析", 
  "status": "完成",
  "insights": ["洞察1", "洞察2"],
  "data_summary": "摘要...",
  "confidence": "中"
}

主代理整合 → 最终输出
```

---

## 实际案例

### 案例：写一篇风水文章

**传统方式（单代理）：**
```
会话1：研究风水知识（30K tokens）
会话2：收集案例（25K tokens）
会话3：撰写文章（40K tokens）
会话4：润色优化（20K tokens）
总计：115K tokens
```

**并行方式（多代理）：**
```
同时启动：
├── 子代理A：搜集3个真实案例（15K）
├── 子代理B：整理风水原理（12K）
└── 子代理C：查找热门话题（10K）

主代理：整合撰写文章（20K）
总计：57K tokens（节省50%）
```

---

## Token优化技巧

### 1. 输出控制
```
子代理指令：
"只返回JSON格式的结果，不要解释，不要思考过程，
 限制在500字以内"
```

### 2. 上下文隔离
```
每个子代理独立会话，不共享上下文
避免上下文窗口膨胀
```

### 3. 结果缓存
```
子代理结果保存到文件
主代理按需读取，不复述完整内容
```

### 4. 分级处理
```
第一层：快速扫描（轻量模型）
第二层：深入分析（中等模型）
第三层：关键决策（强模型）
```

---

## 风险与注意事项

### ⚠️ 潜在问题

1. **结果不一致**
   - 多个子代理可能给出矛盾结论
   - 解决：主代理负责仲裁和整合

2. **任务重叠**
   - 拆分不清导致重复工作
   - 解决：明确的任务边界定义

3. **上下文丢失**
   - 子代理缺乏全局视野
   - 解决：主代理提供足够的背景信息

4. **管理复杂度**
   - 多个子代理增加协调难度
   - 解决：使用结构化输出，自动化整合

### ✅ 最佳实践

1. **明确定义边界**
   ```
   子代理A：只负责X，不涉及Y和Z
   子代理B：只负责Y，基于A的结果
   子代理C：只负责Z，独立于A和B
   ```

2. **设置超时和重试**
   ```json
   {
     "timeoutSeconds": 180,
     "retryCount": 2
   }
   ```

3. **结构化输出**
   ```json
   {
     "status": "完成/部分/失败",
     "result": "具体内容",
     "confidence": "高/中/低",
     "next_steps": ["建议1", "建议2"]
   }
   ```

4. **监控和日志**
   - 记录每个子代理的Token消耗
   - 追踪任务完成时间
   - 分析效率提升数据

---

## 何时使用

### ✅ 推荐使用
- 复杂研究报告（多维度）
- 代码项目（架构+实现+测试）
- 内容生产（批量创作）
- 数据分析（清洗+分析+可视化）
- 决策支持（多方案对比）

### ❌ 不推荐
- 简单问答（拆分开销>收益）
- 创意写作（需要连贯性和迭代）
- 实时对话（延迟敏感）
- 强依赖任务（必须顺序执行）

---

## 成本对比示例

| 任务 | 单代理 | 并行代理 | 节省 |
|------|--------|----------|------|
| 研究报告 | ¥15 | ¥9 | 40% |
| 代码项目 | ¥25 | ¥15 | 40% |
| 内容创作 | ¥10 | ¥6 | 40% |
| 数据分析 | ¥20 | ¥12 | 40% |

*基于Kimi K2.5定价计算*

---

*Version: 1.0*  
*Strategy: Parallel Subagents for Efficiency & Token Optimization*  
*Last updated: 2026-02-13*
